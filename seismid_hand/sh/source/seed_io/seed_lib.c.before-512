
/* file seed_lib.c
 *      ==========
 *
 * version 49, 1-Jul-98
 *
 * SEED library
 * K. Stammler, 29-Dec-93
 * v 16, 22-Nov-94, K. Stammler, added headers for VAX-GCC
 * v 18, 23-Nov-94, K. Stammler, automatic detection of necessary byte swaps
 * v 43,  7-Dec-97, K. Stammler, fixed calib-bug when reading starts in a gap
 * v 44,  9-Dec-97, K. Stammler, fixed bug in ReadNextRecord (appeared in Linux)
 * v 46,  2-Mar-98, K. Stammler, fixed bug on records with too many samples
 * v 47, 24-Mar-98, K. Stammler, was still a bug in records with too many smples
 * v 48, 24-Apr-98, K. Stammler, replaced some printf's by fprintf's
 * v 49,  1-Jun-98, K. Stammler, still another bug at records with bad samples
 */


#include <stdio.h>
#include <string.h>
#include <math.h>
#include BASECNST
#ifdef BC_INC_UNISTD
#include BC_INC_UNISTD
#endif
#ifdef BC_INC_STDLIB
#include BC_INC_STDLIB
#endif
#ifdef BC_SUN
#include <fcntl.h>
#include <sys/types.h>
/* #include <sys/uio.h> */
#endif
#ifdef BC_VAX
#include <file.h>
#endif
#include BC_SYSBASE
#include BC_TCUSRDEF
#include BC_ERUSRDEF
#include BC_UTUSRDEF
#include "seedcfg.h"
#include "seed_lib.h"

#define ANSI_EXTENSIONS
#include "steim1.h"
#undef ANSI_EXTENSIONS

#ifdef BC_VAX
#define SEEK_SET 0
#endif



/*
 * constants
 * ---------
 */

#define PREV_XN_INVALID 0x7fffffffL
#define ROOTDIR "$ROOT"
#define ROOTDIRLTH 5
#define MAX_SMP_PER_REC 5000



/*
 * global variables
 * ----------------
 */

static SeedSetupParT   seedv_setup;                 /* setup parameters */
static SeedFileDescrT  seedv_fd[Seed_C_MAXCHAN];    /* file descriptors */
static SeedDataHeaderT *seedv_rec;                  /* SEED record */
static BOOLEAN         seedv_logrec;                /* log records */
static BOOLEAN         seedv_warnings=TRUE;         /* print warnings */
static BOOLEAN         seedv_invert_swap_hdr=FALSE; /* invert swap hdr flag */
static BOOLEAN         seedv_capfiles=FALSE;        /* capitalized filenames */
static BOOLEAN         seedv_decerr_abort=TRUE;     /* abort on decode errors */
static char            seedv_last_fname[cBcFileLth+1]; /* last file read */

static SeedDataHeaderT seedv_hdr_proto = {        /* SEED header prototype */
	"",                     /* seqno, sequence number string */
	'D',                    /* indicator */
	'\0',                   /* Reserved_bytes_A */
	{'X','X','X',' ',' '},  /* statcode, station name */
	{' ',' '},              /* locid, location identifier */
	{'X','X','X'},          /* channel */
	{'\0','\0'},            /* Reserved_bytes_B */
	{0,0,0,0,0,0,0},        /* starttime */
	0,                      /* no_of_samples */
	1,                      /* smprate_fact */
	1,                      /* smprate_mult */
	0,                      /* activity */
	0,                      /* ioflags */
	0,                      /* quality */
	0,                      /* no_of_blockettes */
	0,                      /* timecorr */
	0,                      /* databegin */
	0                       /* first */
}; /* end of SEED header prototype */

/*
 * prototypes of local routines
 * ----------------------------
 */

static void SeedDecodeSteim1Frame( SeedSbyteT frame[], BOOLEAN swap,
	long diff[], int *lth );
static void SeedAdjustFilename( SeedFileDescrT *dsc, STATUS *status );
static void SeedLibWarning( char text[] );
static void SeedSwapLinuxRecord( SeedSbyteT *rec );

/* #define SeedLibWarning(t) fprintf( stderr, "%s", t ); */



/*---------------------------------------------------------------------*/



void SeedLibInitialize( STATUS *status )

/* Initializes SEED library routines
 *
 * parameters of routine
 * STATUS     *status;      output; return status
 */
{
	/* local variables */
	int      i;            /* counter */

	/* executable code */

	SeedGetSetup( &seedv_setup );
	for  (i=0; i<Seed_C_MAXCHAN; seedv_fd[i++].ufd = Seed_C_ILLEGAL ) {}
	seedv_rec = (SeedDataHeaderT *)sy_allocmem( 1,
		seedv_setup.seed_rec_size, status );
	if  (Severe(status))  return;

} /* end of SeedLibInitialize */



/*---------------------------------------------------------------------*/



void SeedDecodeSteim1( SeedSbyteT rec[], BOOLEAN swap, long maxsmplth,
	long smp[], long *smplth )

/* Decodes Steim1-compressed data record of length 'seedv_setup.seed_rec_size'.
 * Data are returned in array 'smp', its length in 'smplth'.  No more than
 * maxsmplth samples are copied to the output array.  If more samples would
 * be available an error message is printed.
 * A NULL pointer for 'rec' resets internal variables to initial state.
 *
 * parameters of routine
 * SeedSbyteT rec[];          input; SEED record
 * BOOLEAN    swap;           input; swap bytes
 * long       maxsmplth;      input; maximum length of output array
 * long       smp[];          output; decoded samples
 * long       *smplth;        output; number of output samples
 */
{
	/* local variables */
	static long prev_xn=PREV_XN_INVALID;      /* previous xn */
	static int err_cnt=0;          /* error count for diff[0]==x0 */
	SeedSbyteT *frame;             /* byte pointer */
	int        frames_per_rec;     /* number of frames/record (incl. header) */
	int        framecnt;           /* frame counter */
	int        framecnt_start;     /* frame count start value */
	long       x0, xn;             /* integration constants */
	long       diffs[Seed_C_MAXFRAMESMP];  /* differences of one frame */
	int        declth;             /* number of differences in a frame */
	char       str[BC_LINELTH+1];  /* scratch string */
	long       cursmp;             /* current sample */
	long       fsampleno;          /* number of samples in frame */
	SeedDataHeaderT *rec_h;        /* data header structure */
	long       rsampleno;          /* number of samples in record */

	/* executable code */

	if  (rec == NULL)  {
		prev_xn = PREV_XN_INVALID;
		return;
	} /*endif*/

	rec_h = (SeedDataHeaderT *)rec;
	rsampleno = (long)(rec_h->no_of_samples);
	if  (maxsmplth < rsampleno)  {
		sprintf( str,
			"SeedDecodeSteim1: passed array is too short by %ld samples\n",
			rsampleno-maxsmplth );
		SeedLibWarning( str );
		rsampleno = maxsmplth;
	} /*endif*/
	/* printf( "--> databegin: %d\n", (int)rec_h->databegin ); */

	frames_per_rec = seedv_setup.seed_rec_size / Seed_C_FRAMELTH;
	*smplth = 0;
	frame = rec;
	if  (rsampleno <= 0)  return;

	/* skip all frames wich are not data frames (minus one which is */
	/* incremented inside the following loop)                       */
	if  ((int)(rec_h->databegin) % Seed_C_FRAMELTH != 0)  {
		/* illegal value of databegin, print warning and assume it as 64 */
		sprintf( str, "SeedDecodeSteim1: illegal databegin %d\n",
			(int)(rec_h->databegin) );
		SeedLibWarning( str );
	} else {
		framecnt_start = 1;
		/* a value of 0 is corrected to 64 */
		/* values of 128 and more cause a increment of data start frame */
		if  (rec_h->databegin > Seed_C_FRAMELTH)  {
			/*printf( "--> found databegin of %d\n", (int)(rec_h->databegin) );*/
			framecnt_start = (int)(rec_h->databegin) / Seed_C_FRAMELTH;
			frame += (framecnt_start-1)*Seed_C_FRAMELTH;
		} /*endif*/
	} /*endif*/

	/* loop over all frames in record (first frame is header) */
	for  (framecnt=framecnt_start; framecnt<frames_per_rec; framecnt++)  {

		frame += Seed_C_FRAMELTH;

		/* get integration constants */
		if  (framecnt == framecnt_start)  {
			x0 = SeedGet4Bytes( frame+4, swap );
			xn = SeedGet4Bytes( frame+8, swap );
		} /*endif*/

		/* get all differences of this frame */
		SeedDecodeSteim1Frame( frame, swap, diffs, &declth );
		if  (declth > Seed_C_MAXFRAMESMP)  {printf("*****1*****\n"); exit(111);}

		/* check difference to last record */
		if  (framecnt == framecnt_start)  {
			if  (prev_xn+diffs[0] != x0 && prev_xn != PREV_XN_INVALID)  {
				if  (diffs[0] == x0)  {
					/* this is probably a common error in compression */
					if  (err_cnt++ % 100 == 0)  {
						sprintf( str,
							"\n--- Steim1: diff[0] is always equal to x0\n" );
						SeedLibWarning( str );
					} /*endif*/
				} else {
					sprintf( str, "\n--- first sample in record: wrong diff\n" );
					SeedLibWarning( str );
					sprintf( str,
					"    should be (x[-1]+diff[0]) %d, x[0] is %d, diff[0] is %ld\n",
						prev_xn+diffs[0], x0, diffs[0] );
					SeedLibWarning( str );
					/* grn_printhdr( &hdr ); */
				} /*endif*/
			} /*endif*/
			cursmp = x0 - diffs[0];  /* is undone in following loop */
		} /*endif*/

		/* integrate samples and copy to output array */
		for  (fsampleno=0; fsampleno<declth; fsampleno++)  {
			cursmp += diffs[fsampleno];
			*smp++ = cursmp;
			if  (++(*smplth) == rsampleno)  break;
		} /*endfor*/

		if  (*smplth == rsampleno)  break;

	} /*endfor*/

	if  (cursmp != xn)  {
		sprintf( str, "*** checksum not ok in record\n" );
		SeedLibWarning( str );
	} /*endif*/

	prev_xn = xn;

} /* end of SeedDecodeSteim1 */



/*----------------------------------------------------------------------------*/



static void SeedDecodeSteim1Frame( SeedSbyteT frame[], BOOLEAN swap,
	long diff[], int *lth )

/* Decodes differences of a single frame.
 *
 * parameters of routine
 * SeedSbyteT *frame;     input; byte stream
 * BOOLEAN    swap;       input; swap bytes
 * long       diff[];     output; decoded differences
 * int        *lth;       output; number of differences
 */
{
	/* local variables */
	unsigned long   nibbles;    /* 2-bit nibbles */
	int             diffcnt;    /* difference counter */
	int             shift;      /* bit shift length */
	int             diff_id;    /* difference 2-bit ID (0,1,2,3) */
	short int       si;         /* scratch */
	unsigned long   ultmp;      /* scratch */
	SeedSbyteT      sbyte;      /* scratch */

	/* executable code */

	nibbles = SeedGet4Bytes( frame, swap );
	*lth = 0;
	for  (diffcnt=0; diffcnt<Seed_C_FRAMEDIFFS; diffcnt++)  {
		shift = 30 - diffcnt*2;
		diff_id = (int)((nibbles >> shift) & 3);
		switch  (diff_id)  {
		case 1:
			ultmp = SeedGet4Bytes( frame, swap );
			frame += 4;
			sbyte = (SeedSbyteT)((ultmp & 0xff000000L) >> 24);
			diff[(*lth)++] = sbyte;
			sbyte = (SeedSbyteT)((ultmp & 0x00ff0000L) >> 16);
			diff[(*lth)++] = sbyte;
			sbyte = (SeedSbyteT)((ultmp & 0x0000ff00L) >>  8);
			diff[(*lth)++] = sbyte;
			sbyte = (SeedSbyteT)(ultmp & 0x000000ffL);
			diff[(*lth)++] = sbyte;
			break;
		case 2:
			ultmp = SeedGet4Bytes( frame, swap );
			frame += 4;
			si = (short int)((ultmp & 0xffff0000L) >> 16);
			diff[(*lth)++] = si;
			si = (short int)(ultmp & 0x0000ffffL);
			diff[(*lth)++] = si;
			break;
		case 3:
			diff[(*lth)++] = (long)SeedGet4Bytes( frame, swap );
			frame += 4;
			break;
		default:
			frame += 4;  /* no data */
		} /*endswitch*/
	} /*endfor*/

} /* end of SeedDecodeSteim1Frame */



/*----------------------------------------------------------------------------*/



unsigned short int SeedGet2Bytes( SeedSbyteT b[], BOOLEAN swap )

/* returns word from byte stream
 *
 * parameters of routine
 * SeedSbyteT b[];     input;   byte stream
 * BOOLEAN    swap;    input;   swap bytes
 */
{
	/* local variables */
	unsigned short int   word;

	/* executable code */

	if  (swap)  {
		word = ((unsigned short)(b[0]) & 0xff) * 0x100;
		word += (unsigned short)(b[1]) & 0xff;
	} else {
		word = ((unsigned short)(b[1]) & 0xff) * 0x100;
		word += (unsigned short)(b[0]) & 0xff;
	} /*endif*/
	return word;

} /* end of SeedGet2Bytes */



/*----------------------------------------------------------------------------*/



unsigned long int SeedGet4Bytes( SeedSbyteT b[], BOOLEAN swap )

/* returns word from byte stream
 *
 * parameters of routine
 * SeedSbyteT b[];     input;   byte stream
 * BOOLEAN    swap;    input;   swap bytes
 */
{
	/* local variables */
	unsigned long int   lword;

	/* executable code */

	if  (swap)  {
		lword = ((unsigned long)(b[0]) & 0xffL) * 0x1000000L;
		lword += ((unsigned long)(b[1]) & 0xffL) * 0x10000L;
		lword += ((unsigned long)(b[2]) & 0xffL) * 0x100;
		lword += (unsigned long)b[3] & 0xffL;
	} else {
		lword = ((unsigned long)(b[3]) & 0xffL) * 0x1000000L;
		lword += ((unsigned long)(b[2]) & 0xffL) * 0x10000L;
		lword += ((unsigned long)(b[1]) & 0xffL) * 0x100;
		lword += (unsigned long)b[0] & 0xffL;
	} /*endif*/
	return lword;

} /* end of SeedGet4Bytes */



/*---------------------------------------------------------------------*/



void SeedFindFileInSfd( char stream_str[], char start[], char sfdfile[],
	SeedFileDescrT *fdescr, STATUS *status )

/* Finds SEED file in sfd-file of given stream and containing given
 * start time.  If no file is found the file with the next possible
 * time is returned
 *
 * parameters of routine
 * char       stream_str[];      input; stream string like "bfo-vbb-z"
 * char       start[];           input; start time
 * char       sfdfile[];         input; SEED file directory
 * SeedFileDescrT *fdescr;       output; SEED file descriptor
 * STATUS     *status;           output; return status
 */
{
	/* local variables */
	FILE     *sfd;                          /* pointer to sfd-file */
	char     line[Seed_C_SFDLINELTH+1];     /* current line */
	float    tdiff;                         /* time difference */
	float    min_tdiff;                     /* minimum tdiff */
	SeedFileDescrT next;                    /* file with next time */
	SeedFileDescrT curr;                    /* current line */
	char     lstream_str[BC_SHORTSTRLTH+1]; /* local lowercase stream string */

	/* executable code */

	if  (strlen(stream_str) > BC_SHORTSTRLTH)  {
		*status = SeedERR_STROVFL;
		err_setcontext( " ## stream " );
		err_setcontext( stream_str );
		return;
	} /*endif*/

	/* make stream string lowercase */
	strcpy( lstream_str, stream_str );
	ut_uncap( lstream_str );

	/* initialize local descriptors */
	strcpy( next.stream, lstream_str );
	strcpy( curr.stream, lstream_str );
	next.t_start[0] = curr.t_start[0] = '\0';
	next.t_end[0] = curr.t_end[0] = '\0';
	next.name[0] = curr.name[0] = '\0';
	strcpy( next.sfdfile, sfdfile );
	strcpy( curr.sfdfile, sfdfile );
	next.recno = curr.recno = 0;
	next.ufd = curr.ufd = Seed_C_ILLEGAL;
	next.pos = curr.pos = 0;
	next.sample = curr.sample = 0;
	next.calib = curr.calib = 0.0;

	sfd = sy_fopen( sfdfile, "r" );
	if  (sfd == NULL)  {
		*status = SeedERR_OPENINPUT;
		err_setcontext( " ## file " );
		err_setcontext( sfdfile );
		return;
	} /*endif*/

	/* find requested stream and time in sfd-file*/
	next.name[0] = '\0';
	min_tdiff = 1.0e10;
	while  (fgets(line,Seed_C_SFDLINELTH,sfd) != NULL)  {
		if  (*line == '!')  continue;
		SeedParseSfdLine( line, &curr, status );
		if  (Severe(status))  {fclose(sfd); return;}
		if  (strcmp(curr.stream,lstream_str) != 0)  continue;
		tdiff = tc_tdiff( start, curr.t_start, status );
		if  (Severe(status))  {fclose(sfd); return;}
		if  (tdiff >= 0.0 && tc_tdiff(start,curr.t_end,status) < 0.0)  {
			/* found it ! */
			*fdescr = curr;
			fclose( sfd );
			if  (fdescr->calib == 0.0)
				fdescr->calib =
					SeedFindStreamCalibration( fdescr->stream, start, status );
			if  (strncmp(fdescr->name,ROOTDIR,ROOTDIRLTH) == 0)
				SeedAdjustFilename( fdescr, status );
			return;
		} else if  (tdiff < 0.0)  {
			/* store file with time next to requested */
			if  (Severe(status))  {fclose(sfd); return;}
			if  (next.name[0] == '\0' || tdiff > min_tdiff)  {
				min_tdiff = tdiff;
				next = curr;
			} /*endif*/
			if  (next.calib == 0.0)
				next.calib =
					SeedFindStreamCalibration( next.stream, start, status );
		} /*endif*/
		if  (Severe(status))  {fclose(sfd); return;}
	} /*endwhile*/

	*status = (next.name[0] == '\0') ? SeedERR_SFD_NOTFOUND : SeedERR_SFD_NEXT;
	if  (*status == SeedERR_SFD_NOTFOUND)  {
		err_setcontext( " ## stream " );
		err_setcontext( lstream_str );
		err_setcontext( ", time " );
		err_setcontext( start );
	} /*endif*/
	fclose( sfd );
	*fdescr = next;
	if  (strncmp(fdescr->name,ROOTDIR,ROOTDIRLTH) == 0)
		SeedAdjustFilename( fdescr, status );
	return;

} /* end of SeedFindFileInSfd */



/*---------------------------------------------------------------------*/



void SeedSearchPosition( int chan, char sfdfile[], char stream_str[],
	char req_start[], char act_start[], STATUS *status )

/* Searches for given time position in a stream file.  The corresponding
 * SEED file is opened and positioned, its file descriptor stored
 * in an internal variable.  'chan' must range from 0..Seed_C_MAXCHAN-1.
 * If the channel is already used the previously opened file is closed.
 *
 * parameters of routine
 * int        chan;             input; channel number
 * char       sfdfile[];        input; sfd-file
 * char       stream_str[];     input; stream string
 * char       req_start[];      input; requested start time
 * char       act_start[];      output; actual start time
 * STATUS     *status;          output; return status
 */
{
	/* local variables */
	BOOLEAN  next_time;      /* only next time possible */
	float    tdiff_tot;      /* total time window of file */
	float    tdiff_start;    /* difference to request time */
	SeedFileDescrT *fd;      /* pointer to file descriptor */
	long     seek_pos;       /* seek position */
	NTIME    req_ntime;      /* requested time in NTIME format */
	NTIME    cur_ntime;      /* start time of current SEED record */
	float    cur_span;       /* time span (sec) of current SEED record */
	float    dt;             /* sample distance in sec */
	int      jump_rec;       /* number of records to jump */
	int      new_pos;        /* new record position */
	int      jump_cnt;       /* jump counter */

	/* executable code */

	if  (chan < 0 || chan >= Seed_C_MAXCHAN)  {
		*status = SeedERR_CHAN_OOR;
		return;
	} /*endif*/
	fd = seedv_fd + chan;

	if  (fd->ufd != Seed_C_ILLEGAL)  {
		close( fd->ufd );
		fd->ufd = Seed_C_ILLEGAL;
	} /*endif*/

	SeedFindFileInSfd( stream_str, req_start, sfdfile, fd, status );
	next_time =  (*status == SeedERR_SFD_NEXT);
	if  (next_time)  *status = BC_NOERROR;
	if  (Severe(status))  return;

	fd->ufd = open( fd->name, O_RDONLY );
	if  (fd->ufd < 0)  {
		*status = SeedERR_OPENINPUT;
		err_setcontext( " ## file " );
		err_setcontext( fd->name );
		fd->ufd = Seed_C_ILLEGAL;
		return;
	} /*endif*/

	if  (next_time)  {
		strcpy( act_start, fd->t_start );
		*status = SeedERR_NEXTTIMEPOS;
		return;
	} /*endif*/
	tc_t2n( req_start, &req_ntime, status );
	if  (Severe(status))  return;

	/* compute approximate record position */
	tdiff_tot = tc_tdiff( fd->t_end, fd->t_start, status );
	if  (Severe(status))  return;
	tdiff_start = tc_tdiff( req_start, fd->t_start, status );
	if  (Severe(status))  return;
	new_pos = Nint( (float)((fd->recno)-1)/tdiff_tot * tdiff_start );

	for  (jump_cnt=0; jump_cnt<4; jump_cnt++)  {

		/* position SEED file */
		if  (new_pos != fd->pos)  {
			if  (new_pos >= fd->recno)  new_pos = fd->recno-1;
			if  (new_pos < 0)  new_pos = 0;
			fd->pos = new_pos;
			seek_pos = (long)(fd->pos) * (long)seedv_setup.seed_rec_size;
			if  (seedv_logrec)  printf( "-" );
			if  (lseek(fd->ufd,seek_pos,SEEK_SET) != seek_pos)  {
				*status = SeedERR_SEEDSEEK;
				err_setcontext( " ## file " );
				err_setcontext( fd->name );
				return;
			} /*endif*/
		} /*endif*/

		/* read current SEED record */
		if  (seedv_logrec)  printf( "[%d]", fd->pos );  /* log */
		if  (read(fd->ufd,(char *)seedv_rec,seedv_setup.seed_rec_size)
			!= seedv_setup.seed_rec_size)  {
			*status = SeedERR_SEEDREAD;
			err_setcontext( " ## file " );
			err_setcontext( fd->name );
			return;
		} /*endif*/
		(fd->pos)++;
		if  (fd->swap_hdr)  SeedSwapHeader( seedv_rec );
		dt = SeedGetSampleDist( seedv_rec );

		/* check time found (return if time found) */
		SeedBtimeToNtime( &(seedv_rec->starttime), &cur_ntime, status );
		if  (Severe(status))  return;
		tdiff_start = tc_ndiff( &req_ntime, &cur_ntime, status );
		if  (Severe(status))  return;
		cur_span = (float)(seedv_rec->no_of_samples) * dt;
		if  (tdiff_start >= 0.0)  {
			if  (cur_span > tdiff_start)  {
				/* found it ! */
				seek_pos = (long)(--(fd->pos)) * (long)seedv_setup.seed_rec_size;
				lseek( fd->ufd, seek_pos, SEEK_SET );
				fd->sample = Nint( tdiff_start/dt );
				if  (fd->sample >/*=*/ (int)(seedv_rec->no_of_samples))  {
					printf( "! SeedSearchPosition: sample position adjusted (1)\n" );
					fd->sample = seedv_rec->no_of_samples /*- 1*/;
				} /*endif*/
				tc_nadd( &cur_ntime, (fd->sample)*dt, &req_ntime, status );
				if  (Severe(status))  return;
				tc_n2t( &req_ntime, act_start, status );
				return;
			} /*endif*/
		} /*endif*/

		/* estimate next jump */
		if  (tdiff_start > 0.0)  tdiff_start -= cur_span;
		jump_rec = Nint( floor(tdiff_start/cur_span) );
		if  (jump_rec >= 0)  jump_rec++;  else  jump_rec--;
		new_pos = fd->pos - 1 + jump_rec;

	} /*endfor*/

	/* if still not found then read record by record */
	if  (seedv_logrec)  printf( "|" );

	/* go back to time before */
	tdiff_start = tc_ndiff( &req_ntime, &cur_ntime, status );
	while  (tdiff_start < 0.0)  {
		fd->pos -= 2;
		if  (fd->pos < 0)  {
			fprintf( stderr, "*** SeedSearchPosition: this cannot happen (1)\n" );
			*status = SeedERR_BUG;
			return;
		} /*endif*/
		seek_pos = (long)(fd->pos) * (long)seedv_setup.seed_rec_size;
		if  (seedv_logrec)  printf( "-" );
		if  (lseek(fd->ufd,seek_pos,SEEK_SET) != seek_pos)  {
			*status = SeedERR_SEEDSEEK;
			err_setcontext( " ## file " );
			err_setcontext( fd->name );
			return;
		} /*endif*/
		if  (seedv_logrec)  printf( "[%d]", fd->pos );  /* log */
		if  (read(fd->ufd,(char *)seedv_rec,seedv_setup.seed_rec_size)
			!= seedv_setup.seed_rec_size)  {
			*status = SeedERR_SEEDREAD;
			err_setcontext( " ## file " );
			err_setcontext( fd->name );
			return;
		} /*endif*/
		(fd->pos)++;
		if  (fd->swap_hdr)  SeedSwapHeader( seedv_rec );
		dt = SeedGetSampleDist( seedv_rec );
		SeedBtimeToNtime( &(seedv_rec->starttime), &cur_ntime, status );
		if  (Severe(status))  return;
		tdiff_start = tc_ndiff( &req_ntime, &cur_ntime, status );
		if  (Severe(status))  return;
		cur_span = (float)(seedv_rec->no_of_samples) * dt;
	} /*endwhile*/

	/* now find forward */
	while  (tdiff_start >= cur_span)  {
		if  (seedv_logrec)  printf( "[%d]", fd->pos );  /* log */
		if  (read(fd->ufd,(char *)seedv_rec,seedv_setup.seed_rec_size)
			!= seedv_setup.seed_rec_size)  {
			*status = SeedERR_SEEDREAD;
			err_setcontext( " ## file " );
			err_setcontext( fd->name );
			return;
		} /*endif*/
		(fd->pos)++;
		if  (fd->swap_hdr)  SeedSwapHeader( seedv_rec );
		dt = SeedGetSampleDist( seedv_rec );
		SeedBtimeToNtime( &(seedv_rec->starttime), &cur_ntime, status );
		if  (Severe(status))  return;
		tdiff_start = tc_ndiff( &req_ntime, &cur_ntime, status );
		if  (Severe(status))  return;
		cur_span = (float)(seedv_rec->no_of_samples) * dt;
	} /*endwhile*/

	/* step one record back to get it again on next read command */
	seek_pos = (long)(--(fd->pos)) * (long)seedv_setup.seed_rec_size;
	lseek( fd->ufd, seek_pos, SEEK_SET );

	if  (tdiff_start >= 0.0)  {
		/* now found it */
		fd->sample = Nint( tdiff_start/dt );
		if  (fd->sample >/*=*/ (int)(seedv_rec->no_of_samples))  {
			printf( "! SeedSearchPosition: sample position adjusted (2)\n" );
			fd->sample = seedv_rec->no_of_samples /*- 1*/;
		} /*endif*/
		tc_nadd( &cur_ntime, (fd->sample)*dt, &req_ntime, status );
		if  (Severe(status))  return;
		tc_n2t( &req_ntime, act_start, status );
	} else {
		/* time gap */
		/* printf( "*** time gap: next possible time positioned ***\n" ); */
		tc_n2t( &cur_ntime, act_start, status );
		*status = SeedERR_NEXTTIMEPOS;
	} /*endif*/

} /* end of SeedSearchPosition */



/*----------------------------------------------------------------------------*/



void SeedBtimeToNtime( SeedBtimeT *btime, NTIME *ntime, STATUS *status )

/* converts SeedBtimeT to NTIME
 *
 * parameters of routine
 * SeedBtimeT *bt;      input; SEED binary time
 * NTIME      *nt;      output; KS numeric time
 * STATUS     *status;  output; return status
 */
{
	/* executable code */

	ntime->year = btime->year;
	tc_dayofmn( btime->year, btime->day, &(ntime->month),
		&(ntime->day), status );
	if  (Severe(status))  return;
	ntime->hour = btime->hours;
	ntime->min = btime->minutes;
	ntime->sec = btime->seconds;
	ntime->ms = btime->frac_secs/10;

} /* end of SeedBtimeToNtime */



/*----------------------------------------------------------------------------*/



void SeedNtimeToBtime( NTIME *ntime, SeedBtimeT *btime, STATUS *status )

/* converts NTIME to BTIME
 *
 * parameters of routine
 * NTIME      *nt;      input; KS numeric time
 * BTIME      *bt;      output; SEED binary time
 * STATUS     *status;  output; return status
 */
{
	/* executable code */

	btime->year = ntime->year;
	btime->day = tc_julian( ntime->year, ntime->month,
		ntime->day, status );
	if  (Severe(status))  return;
	btime->hours = ntime->hour;
	btime->minutes = ntime->min;
	btime->seconds = ntime->sec;
	btime->frac_secs = ntime->ms*10;

} /* end of SeedNtimeToBtime */



/*---------------------------------------------------------------------*/



float SeedGetSampleDist( SeedDataHeaderT *hdr )

/* Returns sample distance in sec.
 *
 * parameters of routine
 * SeedDataHeaderT  *hdr;        input; SEED data header
 *                               returns sample distance in sec
 */
{
	/* executable code */

	if  (hdr->smprate_fact > 0 && hdr->smprate_mult > 0)  {
		return (1.0/((float)(hdr->smprate_fact) * (float)(hdr->smprate_mult)));
	} else if  (hdr->smprate_fact > 0 && hdr->smprate_mult < 0)  {
		return (-1.0/((float)(hdr->smprate_fact)/(float)(hdr->smprate_mult)));
	} else if  (hdr->smprate_fact < 0 && hdr->smprate_mult > 0)  {
		return (-1.0/((float)(hdr->smprate_mult)/(float)(hdr->smprate_fact)));
	} else if  (hdr->smprate_fact < 0 && hdr->smprate_mult < 0)  {
		return (1.0/((float)(hdr->smprate_fact)/(float)(hdr->smprate_mult)));
	} else {
		fprintf( stderr, "*** illegal sample rate, set dt=1.0\n" );
		return 1.0;
	} /*endif*/

} /* end of SeedGetSampleDist */



/*---------------------------------------------------------------------*/



void SeedReadNextRecord( int chan, SeedSbyteT *rec, BOOLEAN *hdr_swapped,
	STATUS *status )

/* Reads next available record from SEED file.  If the header must be
 * swapped this is done and indicated in '*hdr_swapped'.
 *
 * parameters of routine
 * int        chan;               input; channel number
 * SeedSbyteT *rec;               output; SEED record
 * BOOLEAN    *hdr_swapped;       output; tells whether header was swapped
 * STATUS     *status;            output; return status
 */
{
	/* local variables */
	SeedFileDescrT *fd;                  /* SEED file descriptor */
	char     l_sfdfile[BC_FILELTH+1];    /* local sfdfile */
	char     l_stream[BC_SHORTSTRLTH+1]; /* local stream string */
	char     l_t_end[BC_TIMELTH+1];      /* end of file time */
	char     act_time[BC_TIMELTH+1];     /* positioned time */
	BOOLEAN  time_gap;                   /* time gap found */

	/* executable code */

	/* check channel number */
	if  (chan < 0 || chan >= Seed_C_MAXCHAN)  {
		*status = SeedERR_CHAN_OOR;
		return;
	} /*endif*/
	fd = seedv_fd + chan;

	if  (fd->ufd == Seed_C_ILLEGAL)  {
		*status = SeedERR_NOT_OPEN;
		return;
	} /*endif*/

	/* store filename for last used file request */
	strcpy( seedv_last_fname, fd->name );

	time_gap = FALSE;
	if  (fd->pos >= fd->recno)  {
		/* is at end of file */
		strcpy( l_sfdfile, fd->sfdfile );
		strcpy( l_stream, fd->stream );
		strcpy( l_t_end, fd->t_end );
		SeedSearchPosition( chan, l_sfdfile, l_stream, l_t_end,
			act_time, status );
		time_gap = (*status == SeedERR_NEXTTIMEPOS);
		if  (time_gap)  *status = BC_NOERROR;
		if  (Severe(status))  return;
	} /*endif*/

	if  (seedv_logrec)  printf( "[%d]", fd->pos );  /* log */
	if  (read(fd->ufd,(char *)rec,seedv_setup.seed_rec_size)
		!= seedv_setup.seed_rec_size)  {
		*status = SeedERR_SEEDREAD;
		err_setcontext( " ## file " );
		err_setcontext( fd->name );
		return;
	} /*endif*/
	(fd->pos)++;
	if  (fd->swap_hdr)  SeedSwapHeader( (SeedDataHeaderT *)rec );
	*hdr_swapped = fd->swap_hdr;

	if  (time_gap)  *status = SeedERR_NEXTTIMEPOS;

} /* end of SeedReadNextRecord */



/*---------------------------------------------------------------------*/



void SeedEncodeSteim1( int fd, long smp[], long *prev_smp, long *idx,
	NTIME *ctime, SeedSbyteT *wrk, int wrklth, BOOLEAN complete, STATUS *status )

/* Encodes sample array smp to SEED output file fd (UNIX file descriptor).
 * If complete is set to TRUE the last (probably not completely used)
 * record is written to the file, otherwise the samples of the
 * last record remain in the sample array.
 *
 * parameters of routine
 * int        fd;            input; UNIX file descr of output file
 * long       smp[];         modify; sample array to encode
 * long       *prev_smp;     modify; last sample before smp[0]
 * long       *idx;          modify; length of sample array
 * NTIME      *ctime;        modify; input: start time, output: new start time
 * SeedSbyteT *wrk;          scratch; work space for encoding
 * int        wrklth;        input; length of work space in records
 * BOOLEAN    complete;      input; finish up all records (-> *idx == 0)
 * STATUS     *status;       output; return status
 */
{
	/* local variables */
	static int rec_cnt=1;            /* record counter */
	int      recs_used;              /* number of records used */
	SeedDataHeaderT *hdr;            /* SEED data header */
	int      i;                      /* counter */
	char     str[BC_SHORTSTRLTH+1];  /* scratch string */
	int      write_ret;              /* write return value */
	int      smp_written;            /* total number of samples written to file*/
	float    dt;                     /* sample distance */

	/* executable code */

	/* put start time to header prototype */
	SeedNtimeToBtime( ctime, &seedv_hdr_proto.starttime, status );
	if  (Severe(status))  return;

	if  (*idx <= 0)  return;

	/* encode data */
	recs_used = (int)Steim_comp( smp, (DATA_HEADER *)&seedv_hdr_proto,
		(ULONG)(*idx), (WORD)(seedv_setup.seed_rec_size), (long *)wrk, *prev_smp);
	if  (recs_used > wrklth)  {
		fprintf( stderr,
			"***!!! SeedEncodeSteim1: record array exceeded -> abort !!!***\n" );
		exit( 1 );
	} /*endif*/

	/* if last record not to be written, keep it in smp-buffer */
	if  (complete)  {
		*prev_smp = (*idx > 0) ? smp[(*idx)-1] : 0;
		*idx = 0;
	} else {
		if  (recs_used == 1)  {
			/* printf( "*** SeedEncodeSteim1: only 1 record, no flush\n" ); */
			return;
		} /*endif*/
		hdr = (SeedDataHeaderT *)(wrk + (recs_used-1)*seedv_setup.seed_rec_size);
		*prev_smp = smp[(*idx)-hdr->no_of_samples-1];
		memcpy( (char *)smp, (char *)(smp+(*idx)-(int)(hdr->no_of_samples)),
			(int)(hdr->no_of_samples)*sizeof(long) );
		*idx = hdr->no_of_samples;
		recs_used--;
	} /*endif*/

	/* write records to file */
	smp_written = 0;
	for  (i=0; i<recs_used; i++)  {
		hdr = (SeedDataHeaderT *)(wrk+i*seedv_setup.seed_rec_size);
		sprintf( str, "%06d", rec_cnt++ );
		strncpy( (char *)hdr, str, 6 );
#		ifdef cBc_OS_LINUX
		/* SeedSwapHeader( hdr ); */
		SeedSwapLinuxRecord( (SeedSbyteT *)hdr );
#		endif
		write_ret = (int)write( fd, (char *)hdr, seedv_setup.seed_rec_size );
		if  (write_ret != seedv_setup.seed_rec_size)  {
			*status = SeedERR_SEEDWRITE;
			return;
		} /*endif*/
		smp_written += hdr->no_of_samples;
	} /*endfor*/

	/* update start time */
	dt = SeedGetSampleDist( hdr );
	tc_nadd( ctime, (float)smp_written*dt, ctime, status );

} /* end of SeedEncodeSteim1 */



/*---------------------------------------------------------------------*/



void SeedEncodeSteim1Chan( int fd, long smp[], long *prev_smp, long *idx,
	NTIME *ctime, int *reccnt, SeedDataHeaderT *seedhdr, SeedSbyteT *wrk,
	int wrklth, BOOLEAN complete, STATUS *status )

/* Encodes sample array smp to SEED output file fd (UNIX file descriptor).
 * If complete is set to TRUE the last (probably not completely used)
 * record is written to the file, otherwise the samples of the
 * last record remain in the sample array.
 *
 * This is the same routine as SeedEncodeSteim1Chan except two additional
 * parameters reccnt and seedhdr.
 *
 * parameters of routine
 * int        fd;            input; UNIX file descr of output file
 * long       smp[];         modify; sample array to encode
 * long       *prev_smp;     modify; last sample before smp[0]
 * long       *idx;          modify; length of sample array
 * NTIME      *ctime;        modify; input: start time, output: new start time
 * int        *reccnt;       modify; record counter
 * SeedDataHeaderT *seedhdr; modify; SEED data header
 * SeedSbyteT *wrk;          scratch; work space for encoding
 * int        wrklth;        input; length of work space in records
 * BOOLEAN    complete;      input; finish up all records (-> *idx == 0)
 * STATUS     *status;       output; return status
 */
{
	/* local variables */
	int      recs_used;              /* number of records used */
	SeedDataHeaderT *hdr;            /* SEED data header */
	int      i;                      /* counter */
	char     str[BC_SHORTSTRLTH+1];  /* scratch string */
	int      write_ret;              /* write return value */
	int      smp_written;            /* total number of samples written to file*/
	float    dt;                     /* sample distance */

	/* executable code */

	/* put start time to header prototype */
	SeedNtimeToBtime( ctime, &(seedhdr->starttime), status );
	if  (Severe(status))  return;

	if  (*idx <= 0)  return;

	/* encode data */
	recs_used = (int)Steim_comp( smp, (DATA_HEADER *)seedhdr,
		(ULONG)(*idx), (WORD)(seedv_setup.seed_rec_size), (long *)wrk, *prev_smp);
	if  (recs_used > wrklth)  {
		fprintf( stderr,
			"***!!! SeedEncodeSteim1: record array exceeded -> abort !!!***\n" );
		exit( 1 );
	} /*endif*/

	/* if last record not to be written, keep it in smp-buffer */
	if  (complete)  {
		*prev_smp = (*idx > 0) ? smp[(*idx)-1] : 0;
		*idx = 0;
	} else {
		if  (recs_used == 1)  {
			/* printf( "*** SeedEncodeSteim1: only 1 record, no flush\n" ); */
			return;
		} /*endif*/
		hdr = (SeedDataHeaderT *)(wrk + (recs_used-1)*seedv_setup.seed_rec_size);
		*prev_smp = smp[(*idx)-hdr->no_of_samples-1];
		memcpy( (char *)smp, (char *)(smp+(*idx)-(int)(hdr->no_of_samples)),
			(int)(hdr->no_of_samples)*sizeof(long) );
		*idx = hdr->no_of_samples;
		recs_used--;
	} /*endif*/

	/* write records to file */
	smp_written = 0;
	for  (i=0; i<recs_used; i++)  {
		hdr = (SeedDataHeaderT *)(wrk+i*seedv_setup.seed_rec_size);
		sprintf( str, "%06d", *(reccnt)++ );
		strncpy( (char *)hdr, str, 6 );
		write_ret = (int)write( fd, (char *)hdr, seedv_setup.seed_rec_size );
		if  (write_ret != seedv_setup.seed_rec_size)  {
			*status = SeedERR_SEEDWRITE;
			return;
		} /*endif*/
		smp_written += hdr->no_of_samples;
	} /*endfor*/

	/* update start time */
	dt = SeedGetSampleDist( hdr );
	tc_nadd( ctime, (float)smp_written*dt, ctime, status );

} /* end of SeedEncodeSteim1Chan */



/*---------------------------------------------------------------------*/



void SeedSetHeaderPrototype( SeedDataHeaderT *hdr )

/* copies data header to global variables
 *
 * parameters of routine
 * SeedDataHeaderT *hdr;        input; data header prototype
 */
{
	/* executable code */

	seedv_hdr_proto = *hdr;

} /* end of SeedSetHeaderPrototype */



/*---------------------------------------------------------------------*/



void SeedRecordTime( SeedSbyteT *rec, NTIME *start, NTIME *end,
	STATUS *status )

/* Returns start and end time of SEED record
 *
 * parameters of routine
 * SeedSbyteT *rec;           input; SEED record
 * NTIME      *start;         output; start time of record
 * NTIME      *end;           output; end time of record
 * STATUS     *status;        output; return status
 */
{
	/* local variables */
	SeedDataHeaderT *hdr;    /* pointer to data header */
	float    dt;            /* sample distance in sec */

	/* executable code */

	hdr = (SeedDataHeaderT *)rec;

	SeedBtimeToNtime( &(hdr->starttime), start, status );
	if  (Severe(status))  return;
	dt = SeedGetSampleDist( hdr );
	tc_nadd( start, dt*(float)(hdr->no_of_samples), end, status );

} /* end of SeedRecordTime */



/*---------------------------------------------------------------------*/



/* #ifdef XXX */

#define BUFLTH 4096
/* should be enough for decoding one record */

#define FREE_AND_RETURN		sy_deallocmem( smp ); \
									sy_deallocmem( buf ); \
									sy_deallocmem( encode ); \
									close( out ); \
									return
/* on failure free all memory */




void SeedCopy( int chan, char sfdfile[], char fname[], char stream[],
	char req_begin[], char req_end[], char act_begin[], char act_end[],
	STATUS *status )

/* Copies SEED stream to SEED file
 *
 * parameters of routine
 * int        chan;           input; channel to be used
 * char       sfdfile[];      input; name of sfd-file for input data
 * char       fname[];        input; name of output file
 * char       stream[];       input; stream string
 * char       req_begin[];    input; requested start time
 * char       req_end[];      input; requested end time
 * char       act_begin[];    output; actual start time
 * char       act_end[];      output; actual end time
 * char       *status;        output; return status
 */
{
	/* local variables */
	NTIME    rec_start;        /* record start time */
	NTIME    rec_end;          /* record end time */
	NTIME    n_end;            /* request end time */
	long     *smp;             /* pointer to sample array */
	long     idx;              /* sample index */
	long     *buf;             /* one record buffer */
	long     buflth;           /* length of buffer */
	SeedSbyteT *encode;        /* encode buffer */
	int      encode_lth;       /* length of encode buffer in records */
	float    tdiff;            /* time difference */
	float    dt;               /* sample distance in sec */
	int      out;              /* UNIX file descriptor of output file */
	float    rec_span;         /* time span of record */
	int      i;                /* counter */
	BOOLEAN  quit;             /* quit loop */
	long     smp_written;      /* number of samples written */
	NTIME    ntime;            /* scratch time */
	BOOLEAN  hdr_swapped;      /* header was swapped */

	/* executable code */

	/* allocate memory */
	smp = (long *)sy_allocmem( seedv_setup.copy_buf_lth, (int)sizeof(long),
		status );
	if  (Severe(status))  return;
	buf = (long *)sy_allocmem( BUFLTH, (int)sizeof(long), status );
	if  (Severe(status))  {
		sy_deallocmem( smp );
		return;
	} /*endif*/
	/* encode buffer approximately of equal size as sample buffer 'smp'. */
	/* In the worst case this is not enough, but it is very unlikely.    */
	encode_lth = (int)(seedv_setup.copy_buf_lth*(int)sizeof(long)
		/ seedv_setup.seed_rec_size + 1);
	encode = (SeedSbyteT *)sy_allocmem( encode_lth, seedv_setup.seed_rec_size,
		status );
	if  (Severe(status))  {
		sy_deallocmem( smp );
		sy_deallocmem( buf );
		return;
	} /*endif*/

	/* open output file */
	out = open( fname, O_WRONLY|O_CREAT|O_TRUNC, 0x1ff );
	if  (out < 0)  {
		*status = SeedERR_OPENOUTPUT;
		err_setcontext( " ## file " );
		err_setcontext( fname );
		sy_deallocmem( smp );
		sy_deallocmem( buf );
		sy_deallocmem( encode );
	} /*endif*/

	/* position input file to requested time */
	SeedSearchPosition( chan, sfdfile, stream, req_begin, act_begin, status );
	if  (Severe(status))  {FREE_AND_RETURN;}
	/* check if there are any data in this time window */
	if  (tc_tdiff(act_begin,req_end,status) >= 0.0)  {
		*status = SeedERR_TIMEGAP;
		err_setcontext( " ## no data in requested time window" );
		FREE_AND_RETURN;
	} /*endif*/
	/* initialize values for loop */
	tc_t2n( act_begin, &rec_end, status );
	if  (Severe(status))  {FREE_AND_RETURN;}
	tc_t2n( req_end, &n_end, status );
	if  (Severe(status))  {FREE_AND_RETURN;}
	SeedNtimeToBtime( &rec_end, &seedv_hdr_proto.starttime, status );
	if  (Severe(status))  {FREE_AND_RETURN;}
	/* !!! set record number !!! */
	
	idx = 0;
	quit = FALSE;

	do  {

		/* decode next record */
		SeedReadNextRecord( chan, (SeedSbyteT *)seedv_rec, &hdr_swapped, status );
		if  (Severe(status))  {FREE_AND_RETURN;}
		SeedBtimeToNtime( &(seedv_rec->starttime), &rec_start, status );
		if  (Severe(status))  {FREE_AND_RETURN;}
		SeedDecodeSteim1( (SeedSbyteT *)seedv_rec, !hdr_swapped,
			BUFLTH, buf, &buflth );
		if  (buflth != (long)(seedv_rec->no_of_samples))  {
			fprintf( stderr, "*** inconsistency in sample length: should be %ld, is %ld\n",
				(long)(seedv_rec->no_of_samples), buflth );
		} /*endif*/
		dt = SeedGetSampleDist( seedv_rec );
		/* if decoded values do not fit into smp-array, write it out */
		if  (idx+buflth > seedv_setup.copy_buf_lth)  {
			SeedBtimeToNtime( &seedv_hdr_proto.starttime, &ntime, status );
			if  (Severe(status))  {FREE_AND_RETURN;}
			smp_written = idx;
			SeedEncodeSteim1( out, smp, 0, &idx, &ntime, encode, encode_lth,
				FALSE, status );
			if  (Severe(status))  {FREE_AND_RETURN;}
			smp_written -= idx;
			/* tc_nadd( &ntime, (float)smp_written*dt, &ntime, status ); */
			/* if  (Severe(status))  {FREE_AND_RETURN;} */
			/* SeedNtimeToBtime( &ntime, &seedv_hdr_proto.starttime, status ); */
			/* if  (Severe(status))  {FREE_AND_RETURN;} */
		} /*endif*/
		/* now check for time gap */
		rec_span = dt * (float)(seedv_rec->no_of_samples);
		tdiff = tc_ndiff( &rec_start, &rec_end, status );
		if  (Severe(status))  {FREE_AND_RETURN;}
		/* if there is a time gap, flush smp-buffer and start new record */
		if  (Abs(tdiff) > dt)  {
			printf( "! time gap\n" );
			SeedEncodeSteim1( out, smp, 0, &idx, &ntime, encode, encode_lth, TRUE,
				status );
			if  (Severe(status))  {FREE_AND_RETURN;}
			seedv_hdr_proto.starttime = seedv_rec->starttime;
		} /*endif*/
		/* compute end time for this record, used in next loop */
		tc_nadd( &rec_start, rec_span, &rec_end, status );
		if  (Severe(status))  {FREE_AND_RETURN;}
		/* check whether requested end time is reached */
		tdiff = tc_ndiff( &rec_end, &n_end, status );
		if  (tdiff >= 0.0)  {
			/* if end time reached decrease buflth ... */
			tdiff = tc_ndiff( &n_end, &rec_start, status );
			if  (Severe(status))  {FREE_AND_RETURN;}
			buflth = Nint( tdiff / dt );
			/* ... and compute actual end time */
			tc_nadd( &rec_start, dt*(float)buflth, &n_end, status );
			if  (Severe(status))  {FREE_AND_RETURN;}
			tc_n2t( &n_end, act_end, status );
			if  (Severe(status))  {FREE_AND_RETURN;}
			quit = TRUE;
		} /*endif*/
		/* now add decoded values to smp-array */
		for  (i=0; i<buflth; i++)
			smp[idx++] = buf[i];
		/* if end time found, flush buffer and exit loop */
		if  (quit)
			SeedEncodeSteim1( out, smp, 0, &idx, &ntime, encode, encode_lth, TRUE,
				status );

	}  while (!quit);

	FREE_AND_RETURN;

} /* end of SeedCopy */


#undef FREE_AND_RETURN

/* #endif */

/*---------------------------------------------------------------------*/



#define DO_ABORT \
	*status = SeedERR_SFD_READ; \
	err_setcontext( " ## string " ); err_setcontext( line-1 ); \
	return;




void SeedParseSfdLine( char line[], SeedFileDescrT *fd, STATUS *status )

/* parses line of SFD file.  Returns structure elements 'stream',
 * 't_start', 't_end', 'name', 'recno' and 'calib'.
 *
 * parameters of routine
 * char       line[];       input; SFD line
 * SeedFileDescrT *fd;      output; SEED file descriptor
 * STATUS     *status;      output; return status
 */
{
	/* local variables */

	/* executable code */

	fd->t_start[0] = '\0';
	fd->t_end[0] = '\0';
	fd->name[0] = '\0';
	fd->stream[0] = '\0';
	fd->recno = 0;
	fd->calib = 0.0;
	fd->swap_hdr = FALSE;

	FOREVER  {

		if  (*line == '>')  line++;
		line = strchr( line, '>' );
		if  (line == NULL)  break;
		switch  (*(line-1))  {
		case Seed_C_SfdTStart:
			if  (sscanf(line+1,"%s",fd->t_start) != 1)  { DO_ABORT }
			break;
		case Seed_C_SfdTEnd:
			if  (sscanf(line+1,"%s",fd->t_end) != 1)  { DO_ABORT }
			break;
		case Seed_C_SfdName:
			if  (sscanf(line+1,"%s",fd->name) != 1)  { DO_ABORT }
			break;
		case Seed_C_SfdStream:
			if  (sscanf(line+1,"%s",fd->stream) != 1)  { DO_ABORT }
			break;
		case Seed_C_SfdRecno:
			if  (sscanf(line+1,"%d",&(fd->recno)) != 1)  { DO_ABORT }
			break;
		case Seed_C_SfdCalib:
			if  (sscanf(line+1,"%f",&(fd->calib)) != 1)  { DO_ABORT }
			break;
		case Seed_C_SfdSwapH:
			if  (sscanf(line+1,"%d",&(fd->swap_hdr)) != 1)  { DO_ABORT }
			if  (seedv_invert_swap_hdr)  fd->swap_hdr = ! fd->swap_hdr;
			break;
		} /*endswitch*/

	} /*endfor*/

} /* end of SeedParseSfdLine */



#undef DO_ABORT



/*---------------------------------------------------------------------*/



void SeedReadStream( int chan, char sfdfile[], char stream_str[],
	BOOLEAN swap, char req_start[], float seclth, long **ldat,
	long *smplth, char act_start[], float *dt, float *calib,
	STATUS *status )

/* Reads sample data from SEED stream.  The memory for the sample
 * data is allocated by the routine.  The channel number is chosen
 * by the caller of the routine.  It is legal to use always channel
 * number 0 but it is faster to use a separate channel number for
 * each stream used if the streams are read repeatedly.
 *
 * parameters of routine
 * int        chan;         input; channel number (0..Seed_C_MAXCHAN-1)
 * char       sfdfile[];    input; name of sfd file to use
 * char       stream_str[]; input; stream string (like "bfo-vbb-z")
 * BOOLEAN    swap;         input; swap bytes on file
 * char       req_start[];  input; requested start time
 * float      seclth;       input; number of seconds to be read
 * long       **ldat;       output; sample array read
 * long       *smplth;      output; number of samples read
 * char       act_start[];  output; actual start time
 * float      *dt;          output; sample distance in sec
 * float      *calib;       output; calibration constant
 * STATUS     *status;      output; return status
 */
{
	/* local variables */
	SeedFileDescrT *fd;   /* pointer to SEED file descriptor */
	long     getlth;      /* number of samples to read */
	long     maxrecsmp;   /* maximum number of samples per record */
	long     actrecsmp;   /* actual number of samples in record */
	long     *recsmp;     /* pointer to samples of record */
	long     *lsrc, *ldst;/* moving pointers */
	NTIME    recstart;    /* record start time */
	NTIME    recend;      /* record end time */
	NTIME    expectime;   /* expected time */
	float    tdiff;       /* time gap in sec */
	long     padcnt;      /* counter for zero padding */
	char     str[BC_TIMELTH+1];  /* scratch string for time output */
	BOOLEAN  swap_data;   /* swap data */
	int      i;           /* counter */

	/* executable code */

	/* check channel number */
	if  (chan < 0 || chan >= Seed_C_MAXCHAN)  {
		*status = SeedERR_CHAN_OOR;
		return;
	} /*endif*/
	fd = seedv_fd + chan;

	/* find requested position */
	tdiff = 0.0;
	SeedSearchPosition( chan, sfdfile, stream_str, req_start,
		act_start, status );
	if  (*status == SeedERR_NEXTTIMEPOS)  {
		*status = BC_NOERROR;
		tdiff = tc_tdiff( act_start, req_start, status );
		if  (Severe(status))  return;
		if  (tdiff >= seclth)  {*status = SeedERR_DATA_UNAVAIL; return;}
		fprintf( stderr,
			"SeedReadStream: time %s not found, start at %s\n",
			req_start, act_start );
	} /*endif*/
	if  (Severe(status))  return;

	maxrecsmp = 5000;   /* !!! */
	*smplth = 0;
	*ldat = NULL;
	recsmp = NULL;
	*dt = 0.0;
	expectime.year = 0;
	/* reset decode routine */
	SeedDecodeSteim1( NULL, swap, 0, NULL, NULL );

	FOREVER  {

		/* read next record */
		SeedReadNextRecord( chan, (SeedSbyteT *)seedv_rec, &swap_data, status );
		if  (swap)  swap_data = !swap_data;
		if  (*status == SeedERR_NEXTTIMEPOS)  *status = BC_NOERROR;
		if  (Severe(status))  return;

		/* decode SEED record and select samples */
		/* ------------------------------------- */
		if  (*ldat == NULL)  {

			/* this is for first loop only */
			/* --------------------------- */
			*calib = fd->calib;
			*dt = SeedGetSampleDist( seedv_rec );
			getlth = Nlong( seclth / *dt );
			if  (getlth <= 0)  {*status = SeedERR_ZEROLTH; return;}
			*ldat = (long *)sy_allocmem( getlth, (int)sizeof(long), status );
			if  (Severe(status))  return;
			ldst = *ldat;
			recsmp = (long *)sy_allocmem( maxrecsmp, (int)sizeof(long), status );
			if  (Severe(status))  {sy_deallocmem(*ldat); return;}
			/* if time gap at beginning, pad zeroes */
			if  (tdiff > 0.0)  {
				/* pad with zeroes and adjust start time */
				padcnt = Nlong( tdiff / (*dt) );
				fprintf( stderr, "SeedReadStream: record %6s, time %s\n",
					seedv_rec->seqno, act_start );
				fprintf( stderr, "   gap %5.3f sec, start with %ld zeroes\n",
					tdiff, padcnt );
				tc_tadd( act_start, -(*dt)*(float)padcnt, act_start, status );
				if  (Severe(status))  *status = BC_NOERROR; /* ok, not elegant */
				while  (padcnt-- > 0)  {
					ldst[(*smplth)++] = 0;
					if  (*smplth == getlth)  {
						sy_deallocmem( recsmp );
						fprintf( stderr,
							"   padding aborted, %ld zeroes remaining\n", padcnt );
						strcpy( act_start, req_start );
						return;
					} /*endif*/
				} /*endwhile*/
			} /*endif*/
			SeedDecodeSteim1( (SeedSbyteT *)seedv_rec, swap_data,
				maxrecsmp, recsmp, &actrecsmp );
			if  (actrecsmp != seedv_rec->no_of_samples)  {
				fprintf( stderr,
					"*** seed record samples: expected %d, actual: %d\n",
					seedv_rec->no_of_samples, actrecsmp );
				if  (seedv_decerr_abort)  {
					sy_deallocmem( *ldat );
					*ldat = NULL;
					sy_deallocmem( recsmp );
					*status = SeedERR_DECODE_ERR;
					return;
				} else {
					long    zeronum;       /* number of sample to zero */
					zeronum = seedv_rec->no_of_samples;
					if  (zeronum > maxrecsmp)  zeronum = maxrecsmp;
					fprintf( stderr, "   zero %d samples and continue\n", zeronum );
					for  (i=0; i<zeronum; i++)
						recsmp[i] = 0;
				} /*endif*/
#				ifdef XXX
				/* excluded this on 1-Jul-98, K.S. */
				fd->sample = 0;
				fprintf( stderr,
					"   read position within zeroed record set to zero\n" );
#				endif
				actrecsmp = seedv_rec->no_of_samples;
			} /*endif*/
			lsrc = recsmp + fd->sample;
			actrecsmp -= fd->sample;
			if  (actrecsmp < 0)  {
				sy_deallocmem( *ldat );
				*ldat = NULL;
				sy_deallocmem( recsmp );
				*status = SeedERR_BUG;
				fprintf( stderr, "*** SeedReadStream: bug (1) [sample: %d] ***\n",
					fd->sample );
				return;
			} /*endif*/
			SeedRecordTime( (SeedSbyteT *)seedv_rec, &recstart, &expectime,
				status );
			if  (Severe(status))  return;

		} else {

			/* this is for all other loops */
			/* --------------------------- */

			/* decode record */
			SeedDecodeSteim1( (SeedSbyteT *)seedv_rec, swap_data,
				maxrecsmp, recsmp, &actrecsmp );
			if  (actrecsmp != seedv_rec->no_of_samples)  {
				fprintf( stderr,
					"*** seed record samples: expected %d, actual: %d\n",
					seedv_rec->no_of_samples, actrecsmp );
				if  (seedv_decerr_abort)  {
					sy_deallocmem( *ldat );
					*ldat = NULL;
					sy_deallocmem( recsmp );
					*status = SeedERR_DECODE_ERR;
					return;
				} else {
					long    zeronum;       /* number of sample to zero */
					zeronum = seedv_rec->no_of_samples;
					if  (zeronum > maxrecsmp)  zeronum = maxrecsmp;
					fprintf( stderr, "   zero %d samples and continue\n", zeronum );
					for  (i=0; i<zeronum; i++)
						recsmp[i] = 0;
				} /*endif*/
				actrecsmp = seedv_rec->no_of_samples;
			} /*endif*/
			lsrc = recsmp;

			/* check for time gaps, pad with zeroes */
			SeedRecordTime( (SeedSbyteT *)seedv_rec, &recstart, &recend, status );
			if  (Severe(status))  return;
			tdiff = tc_ndiff( &recstart, &expectime, status );
			if  (Severe(status))  return;
			if  (tdiff <= -(*dt))  {
				/* double data */
				padcnt = Nlong( -tdiff / (*dt) );
				tc_n2t( &recstart, str, status );
				fprintf( stderr, "SeedReadStream: record %6s, time %s\n",
					seedv_rec->seqno, str );
				fprintf( stderr, "   double data, %ld samples skipped\n",
					padcnt );
				if  (padcnt > (long)(seedv_rec->no_of_samples))  {
					*status = SeedERR_DOUBLEDATA;
					sy_deallocmem( recsmp );
					return;
				} /*endif*/
				/* skip samples */
				lsrc += padcnt;
				actrecsmp -= padcnt;
			} else if  (tdiff >= (*dt))  {
				/* time gap */
				padcnt = Nlong( tdiff / (*dt) );
				tc_n2t( &recstart, str, status );
				fprintf( stderr, "SeedReadStream: record %6s, time %s\n",
					seedv_rec->seqno, str );
				fprintf( stderr,
					"   gap %5.3f sec, padding %ld zeroes at sample %ld\n",
					tdiff, padcnt, *smplth );
				/* pad zeroes */
				while  (padcnt-- > 0)  {
					ldst[(*smplth)++] = 0;
					if  (*smplth == getlth)  {
						sy_deallocmem( recsmp );
						fprintf( stderr, 
							"   padding aborted, %ld zeroes remaining\n", padcnt );
						return;
					} /*endif*/
				} /*endwhile*/
			} /*endif*/
			expectime = recend;

		} /*endif*/

		/* copy samples to output array */
		while  (actrecsmp-- > 0)  {
			ldst[(*smplth)++] = *lsrc++;
			if  (*smplth == getlth)  {  /* finished ! */
				sy_deallocmem( recsmp );
				return;
			} /*endif*/
		} /*endwhile*/

	} /*endfor*/

} /* end of SeedReadStream */



/*---------------------------------------------------------------------*/



void SeedReadStreamReal( int chan, char sfdfile[], char stream_str[],
	BOOLEAN swap, char req_start[], float seclth, float **fdat,
	long *smplth, char act_start[], float *dt, float *calib,
	STATUS *status )

/* Same as SeedReadStream except that a float array is returned
 *
 * parameters of routine
 * see SeedReadStream above
 */
{
	/* local variables */
	long     *lptr;         /* long pointer to data array */
	long     *lp;           /* moving pointer */
	float    *fp;           /* moving pointer */
	long     i;             /* counter */

	/* executable code */

	SeedReadStream( chan, sfdfile, stream_str, swap, req_start,
		seclth, &lptr, smplth, act_start, dt, calib, status );
	if  (Severe(status))  return;

	if  (sizeof(long) != sizeof(float))  {
		printf( "--> sizeof(float) != sizeof(long)\n" );
		*status = 1;
		sy_deallocmem( lptr );
		return;
	} /*endif*/

	lp = lptr;
	fp = *fdat = (float *)lptr;
	for  (i=0; i<(*smplth); i++)
		*fp++ = (float)(*lp++) * (*calib);

} /* end of SeedReadStreamReal */



/*---------------------------------------------------------------------*/



float SeedFindStreamCalibration( char stream[], char stime[], STATUS *status )

/* returns calibration value for counts for given stream 'stream' at time
 * 'stime'.
 *
 * parameters of routine
 * char           stream[];     input; stream string
 * char           stime[];      input; time
 * STATUS         *status;      output; return status
 *                              returns calibration or 0.0
 */
{
	/* local variables */
	char     calfile[BC_FILELTH+1];    /* name of calibration file */
	char     *eptr;                    /* pointer to environment variable */
	FILE     *fp;                      /* pointer to input file */
	char     line[BC_LINELTH+1];       /* current line of input file */
	char     v_start[BC_LINELTH+1];    /* start of valid time */
	char     v_end[BC_LINELTH+1];      /* end of valid time */
	float    lcalib;                   /* current value of calibration */

	/* executable code */

	/* build filename */
	*calfile = '\0';
	eptr = getenv( "SEED_INPUTS" );
	if  (eptr != NULL)  {
		if  (strlen(eptr)+strlen(stream)+11 > BC_FILELTH)  {
			*status = SeedERR_STROVFL;
			return 0.0;
		} /*endif*/
		strcpy( calfile, eptr );
		strcat( calfile, "/" );
	} /*endif*/
	strcat( calfile, "seedcalib_" );
	strcat( calfile, stream );

	/* open file */
	fp = sy_fopen( calfile, "r" );
	if  (fp == NULL)  {
		fprintf( stderr, "--> no calibration for %s, set to 1.0\n", stream );
		return 1.0;
	} /*endif*/

	while  (fgets(line,BC_LINELTH,fp) != NULL)  {
		if  (*line == '!' || *line == '\n')  continue;
		if  (sscanf(line,"%s %s %f",v_start,v_end,&lcalib) != 3)  {
			fprintf( stderr, "--> format error in calibration file %s\n", stream );
			continue;
		} /*endif*/
		if  (tc_tdiff(stime,v_start,status) < 0.0)  continue;
		if  (Severe(status))  return 0.0;
		if  (tc_tdiff(stime,v_end,status) > 0.0)  continue;
		if  (Severe(status))  return 0.0;
		sy_fclose( fp );
		return lcalib;
	} /*endwhile*/

	sy_fclose( fp );
	fprintf( stderr, "--> no valid calibration for %s %s, set to 1.0\n",
		stream, stime );
	return 1.0;

} /* end of SeedFindStreamCalibration */



/*---------------------------------------------------------------------*/



void SeedGetTimeSpan( char sfdfile[], char stream[], char start[],
	char end[], STATUS *status )

/* Returns first and last time of channel 'stream' in sfd-file
 *
 * parameters of routine
 * char       sfdfile[];        input; name of sfd-file
 * char       stream[];         input; stream string to be checked
 * char       start[];          output; first start time
 * char       end[];            output; last end time
 * STATUS     *status;          output; return status
 */
{
	/* local variables */
	FILE     *sfd;                      /* pointer to sfd-file */
	char     line[Seed_C_SFDLINELTH+1]; /* current sfd-line */
	SeedFileDescrT dsc;                 /* sfd descriptor */
	char     lstream[BC_SHORTSTRLTH+1]; /* lowercase stream name */

	/* executable code */

	sfd = sy_fopen( sfdfile, "r" );
	if  (sfd == NULL)  {
		*status = SeedERR_OPENINPUT;
		err_setcontext( " ## file " );
		err_setcontext( sfdfile );
		return;
	} /*endif*/

	strcpy( lstream, stream );
	ut_uncap( lstream );

	/* find requested stream */
	*start = *end = '\0';
	while  (fgets(line,Seed_C_SFDLINELTH,sfd) != NULL)  {
		if  (*line == '!')  continue;
		SeedParseSfdLine( line, &dsc, status );
		if  (strcmp(dsc.stream,lstream) != 0)  continue;
		if  (*start == '\0')  {
			strcpy( start, dsc.t_start );
		} else {
			if  (tc_tdiff(dsc.t_start,start,status) < 0.0)
				strcpy( start, dsc.t_start );
		} /*endif*/
		if  (Severe(status))  return;
		if  (*end == '\0')  {
			strcpy( end, dsc.t_end );
		} else {
			if  (tc_tdiff(dsc.t_end,end,status) > 0.0)
				strcpy( end, dsc.t_end );
		} /*endif*/
		if  (Severe(status))  return;
	} /*endwhile*/

	sy_fclose( sfd );

} /* end of SeedGetTimeSpan */



/*---------------------------------------------------------------------*/



BOOLEAN SeedInquireTime( char sfdfile[], char stream[], char start[],
	char end[], STATUS *status )

/* Checks whether the specified time span from 'start' to 'end' is
 * available for channel 'stream' in sfd-file 'sfdfile'
 *
 * parameters of routine
 * char       sfdfile[];        input; name of sfd-file
 * char       stream[];         input; stream string
 * char       start[];          input; start time
 * char       end[];            input; end time
 * STATUS     *status;          output; return status
 *                              returns TRUE if data are available
 */
{
	/* local variables */
	FILE     *sfd;                      /* pointer to sfd-file */
	char     line[Seed_C_SFDLINELTH+1]; /* current sfd-line */
	SeedFileDescrT dsc;                 /* sfd descriptor */
	char     lstream[BC_SHORTSTRLTH+1]; /* lowercase stream name */
	TIME     a_start, a_end;            /* absolute times of inquied span */
	TIME     a1, a2;                    /* absolute times of SEED file */

	/* executable code */

	sfd = sy_fopen( sfdfile, "r" );
	if  (sfd == NULL)  {
		*status = SeedERR_OPENINPUT;
		err_setcontext( " ## file " );
		err_setcontext( sfdfile );
		return FALSE;
	} /*endif*/

	strcpy( lstream, stream );
	ut_uncap( lstream );

	tc_t2a( start, &a_start, status );
	if  (Severe(status))  {sy_fclose(sfd); return FALSE;}
	tc_t2a( end, &a_end, status );
	if  (Severe(status))  {sy_fclose(sfd); return FALSE;}
	if  (tc_adiff(&a_end,&a_start) < 0.0)  {sy_fclose(sfd); return FALSE;}

	while  (fgets(line,Seed_C_SFDLINELTH,sfd) != NULL)  {
		if  (*line == '!')  continue;
		SeedParseSfdLine( line, &dsc, status );
		if  (strcmp(dsc.stream,lstream) != 0)  continue;
		tc_t2a( dsc.t_start, &a1, status );
		if  (Severe(status))  {sy_fclose(sfd); return FALSE;}
		tc_t2a( dsc.t_end, &a2, status );
		if  (Severe(status))  {sy_fclose(sfd); return FALSE;}
		if  (tc_adiff(&a_start,&a1) < 0.0)  continue;
		if  (tc_adiff(&a2,&a_end) < 0.0)  continue;
		sy_fclose( sfd );
		return TRUE;
	} /*endwhile*/

	sy_fclose( sfd );

	return FALSE;

} /* end of SeedInquireTime */



/*---------------------------------------------------------------------*/



void SeedInquireTimeList( char sfdfile[], char stations[], int itemlth,
	int listlth, char chan[], char comp, char start[], char end[],
	long *avail, STATUS *status )

/* Checks whether the specified time span from 'start' to 'end' is
 * available for all stations (stream 'station-chan-comp') in sfd-file
 * 'sfdfile'.  'station' is a char string with 'listlth' equidistant
 * strings of length 'itemlth'.
 *
 * parameters of routine
 * char       sfdfile[];        input; name of sfd-file
 * char       stations[];       input; list of stations
 * int        itemlth;          input; chars used for a station name
 * int        listlth;          input; length of list (# of stations) (<= 32)
 * char       chan[];           input; 2-char channel string
 * char       comp;             input; component
 * char       start[];          input; start time
 * char       end[];            input; end time
 * long       *avail;           output; station bits
 * STATUS     *status;          output; return status
 */
{
	/* local variables */
	FILE     *sfd;                      /* pointer to sfd-file */
	char     line[Seed_C_SFDLINELTH+1]; /* current sfd-line */
	SeedFileDescrT dsc;                 /* sfd descriptor */
	char     lstream[BC_SHORTSTRLTH+1]; /* lowercase stream name */
	TIME     a_start, a_end;            /* absolute times of inquied span */
	TIME     a1, a2;                    /* absolute times of SEED file */
	char     *sptr;                     /* current station name */
	int      scnt;                      /* station counter */
	char     cmpstr[2];                 /* component */

	/* executable code */

	sfd = sy_fopen( sfdfile, "r" );
	if  (sfd == NULL)  {
		*status = SeedERR_OPENINPUT;
		err_setcontext( " ## file " );
		err_setcontext( sfdfile );
		return;
	} /*endif*/

	tc_t2a( start, &a_start, status );
	if  (Severe(status))  {sy_fclose(sfd); return;}
	tc_t2a( end, &a_end, status );
	if  (Severe(status))  {sy_fclose(sfd); return;}
	if  (tc_adiff(&a_end,&a_start) < 0.0)  {sy_fclose(sfd); return;}

	cmpstr[0] = comp;
	cmpstr[1] = '\0';

	*avail = 0;

	while  (fgets(line,Seed_C_SFDLINELTH,sfd) != NULL)  {

		/* get & parse next sfd line */
		if  (*line == '!')  continue;
		SeedParseSfdLine( line, &dsc, status );

		/* check time */
		tc_t2a( dsc.t_start, &a1, status );
		if  (Severe(status))  {sy_fclose(sfd); return;}
		tc_t2a( dsc.t_end, &a2, status );
		if  (Severe(status))  {sy_fclose(sfd); return;}
		if  (tc_adiff(&a_start,&a1) < 0.0)  continue;
		if  (tc_adiff(&a2,&a_end) < 0.0)  continue;

		/* now loop all stations */
		sptr = stations;
		for  (scnt=0; scnt<listlth; scnt++)  {
			if  (*sptr != '-')  {
				/* build stream name */
				strcpy( lstream, sptr );
					strcat( lstream, "-" );
				strcat( lstream, chan );
				strcat( lstream, "-" );
				strcat( lstream, cmpstr );
				ut_uncap( lstream );
				if  (strcmp(dsc.stream,lstream) == 0)
					*avail |= (1<<scnt);
			} /*endif*/
			/* increment station pointer */
			sptr += itemlth;
		} /*endfor*/

	} /*endwhile*/

	sy_fclose( sfd );

} /* end of SeedInquireTimeList */



/*---------------------------------------------------------------------*/



BOOLEAN SeedSwapNecessary( SeedDataHeaderT *hdr )

/* Checks whether a swap is necessary on data header
 *
 * parameters of routine
 * SeedDataHeaderT *hdr;     input; header to check
 *                           returns TRUE if swap must be performed
 */
{
	/* executable code */

	return  (hdr->starttime.year < 1950 || hdr->starttime.year > 2010);

} /* end of SeedSwapNecessary */



/*---------------------------------------------------------------------*/



void SeedSwapHeader( SeedDataHeaderT *hdr )

/* Swaps words and longwords in header
 *
 * parameters of routine
 * SeedDataHeaderT *hdr;          modify; data heaer to be swapped
 */
{
	/* local variables */
	WORD     v_word;      /* scratch */
	UWORD    v_uword;     /* scratch */
	LONG     v_long;      /* scratch */

	/* executable code */

	v_uword = hdr->starttime.year;
	hdr->starttime.year = (v_uword & 0xff) * 0x100;
	hdr->starttime.year += (UWORD)(v_uword & 0xff00) / (UWORD)0x100;

	v_uword = hdr->starttime.day;
	hdr->starttime.day = (v_uword & 0xff) * 0x100;
	hdr->starttime.day += (UWORD)(v_uword & 0xff00) / (UWORD)0x100;

	v_uword = hdr->starttime.frac_secs;
	hdr->starttime.frac_secs = (v_uword & 0xff) * 0x100;
	hdr->starttime.frac_secs += (UWORD)(v_uword & 0xff00) / (UWORD)0x100;

	v_uword = hdr->no_of_samples;
	hdr->no_of_samples = (v_uword & 0xff) * 0x100;
	hdr->no_of_samples += (UWORD)(v_uword & 0xff00) / (UWORD)0x100;

	v_uword = (UWORD)(hdr->smprate_fact);
	hdr->smprate_fact = (int)( ((v_uword << 8) & 0xff00) |
		((v_uword >> 8) & 0x00ff) );

	v_uword = (UWORD)(hdr->smprate_mult);
	hdr->smprate_mult = (int)( ((v_uword << 8) & 0xff00) |
		((v_uword >> 8) & 0x00ff) );

	v_long = hdr->timecorr;
	hdr->timecorr =  (LONG)(((ULONG)v_long & 0x000000ffL) * (ULONG)0x1000000L);
	hdr->timecorr += (LONG)(((ULONG)v_long & 0x0000ff00L) * (ULONG)0x100L);
	hdr->timecorr += (LONG)(((ULONG)v_long & 0x00ff0000L) >> (ULONG)8L);
	hdr->timecorr += (LONG)(((ULONG)v_long & 0xff000000L) >> (ULONG)24L);

	v_uword = hdr->databegin;
	hdr->databegin = (v_uword & 0xff) * 0x100;
	hdr->databegin += (UWORD)(v_uword & 0xff00) / (UWORD)0x100;

	v_uword = hdr->first;
	hdr->first = (v_uword & 0xff) * 0x100;
	hdr->first += (UWORD)(v_uword & 0xff00) / (UWORD)0x100;

} /* end of SeedSwapHeader */



/*---------------------------------------------------------------------*/



void SeedCloseFiles( void )

/* closes all open SEED files
 *
 * no parameters
 */
{
	/* local variables */
	int      i;         /* counter */

	/* executable code */

	for  (i=0; i<Seed_C_MAXCHAN; i++)
		if  (seedv_fd[i].ufd != Seed_C_ILLEGAL)  {
			close( seedv_fd[i].ufd );
			seedv_fd[i].ufd = Seed_C_ILLEGAL;
		} /*endif*/

} /* end of SeedCloseFiles */



/*---------------------------------------------------------------------*/



static void SeedAdjustFilename( SeedFileDescrT *dsc, STATUS *status )

/* copies directory of sfd-file to data filename
 *
 * parameters of routine
 * SeedFileDescrT  *dsc;        modify; SEED file descriptor
 * STATUS          *status;     output; return status
 */
{
	/* local variables */
	int      i;                      /* counter */
	int      strlth;                 /* string length */
	char     path[BC_FILELTH+1];     /* path name */
	BOOLEAN  iscolon;                /* is there a colon ? */
	char     upname[cBcFileLth+1];   /* uppercase filename */

	/* executable code */

	/* find path in sfdfile */
	i = strlen( dsc->sfdfile ) - 1;
	while  (i >= 0 && dsc->sfdfile[i] != '/' && dsc->sfdfile[i] != ':'
		&& dsc->sfdfile[i] != '\\')  i--;
	if  (i > 0)  {
		strncpy( path, dsc->sfdfile, i );
		path[i] = '\0';
		iscolon = (dsc->sfdfile[i] == ':');
	} else {
		*path = '\0';
		iscolon = FALSE;
	} /*endif*/

	if  (strlen(dsc->name)-ROOTDIRLTH+strlen(path) > BC_FILELTH)  {
		*status = SeedERR_STROVFL;
		return;
	} /*endif*/

	if  (*path != '\0')  {
		strlth = strlen( path );
		for  (i=0; i<strlth; i++)
			if  (path[i] == '\\')  path[i] = '/';
		if  (iscolon)  {
			strcat( path, ":" );
			if  (seedv_capfiles)  {
				strcpy( upname, dsc->name+ROOTDIRLTH+1 );
				ut_cap( upname );
				strcat( path, upname );
			} else {
				strcat( path, dsc->name+ROOTDIRLTH+1 );
			} /*endif*/
		} else {
			if  (seedv_capfiles)  {
				strcpy( upname, dsc->name+ROOTDIRLTH );
				ut_cap( upname );
				strcat( path, upname );
			} else {
				strcat( path, dsc->name+ROOTDIRLTH );
			} /*endif*/
		} /*endif*/
	} else {
		strcpy( path, dsc->name+ROOTDIRLTH+1 );
	} /*endif*/
	strcpy( dsc->name, path );

} /* end of SeedAdjustFilename */



/*---------------------------------------------------------------------*/


static void SeedLibWarning( char text[] )

/* prints warning messages
 *
 * parameters of routine
 * char       text[];      input; output text
 */
{
	/* executable code */

	if  (seedv_warnings)  fprintf( stderr, "%s", text );

} /* end of SeedLibWarning */



/*---------------------------------------------------------------------*/



void SeedPrintWarnings( BOOLEAN on_off )

/* switches warning messages on or off
 *
 * parameters of routine
 * BOOLEAN    on_off;       input; switch
 */
{
	/* executable code */

	seedv_warnings = on_off;

} /* end of SeedPrintWarnings */



/*---------------------------------------------------------------------*/



void SeedAcceptCapfiles( BOOLEAN on_off )

/* switches on/off whether capitalized filenames on $ROOT-paths are accepted
 *
 * parameters of routine
 * BOOLEAN    on_off;       input; switch
 */
{
	/* executable code */

	seedv_capfiles = on_off;

} /* end of SeedPrintWarnings */



/*---------------------------------------------------------------------*/



BOOLEAN SeedSetInvertSwapHeader( BOOLEAN on_off )

/* Sets the global variable seedv_invert_swap_hdr to invert header swap
 * info in sfd-file.  Returns old value.
 *
 * parameters of routine
 * BOOLEAN    on_off;    input; switch value
 */
{
	/* local variables */
	BOOLEAN  old;

	/* executable code */

	old = seedv_invert_swap_hdr;
	seedv_invert_swap_hdr = on_off;
	return old;

} /* end of SeedSetInvertSwapHeader */



/*---------------------------------------------------------------------*/



BOOLEAN SeedSetDecodeErrorAbort( BOOLEAN on_off )

/* Sets the global value seedv_decerr_abort (abort on occurrence of
 * SEED decoding errors.  Returns old value.
 *
 * parameters of routine
 * BOOLEAN    on_off;        input; switch value
 */
{
	/* local variables */
	BOOLEAN  old;        /* old value */

	/* executable code */

	old = seedv_decerr_abort;
	seedv_decerr_abort = on_off;
	return old;

} /* end of SeedSetDecodeErrorAbort */



/*---------------------------------------------------------------------*/



void SeedCutStartRecord( SeedSbyteT *seedrec, char extime[], BOOLEAN swap,
	STATUS *status )

/* Throws away the first samples in record until given time
 *
 * parameters of routine
 * char       *seedrec;         modify; SEED record to cut
 * char       extime[];         input; exact time
 * BOOLEAN    swap;             input; swap bytes ?
 * STATUS     *status;          output; return status
 */
{
	/* local variables */
	SeedDataHeaderT *hdrptr;   /* pointer to data header */
	SeedDataHeaderT *outrec;   /* output records */
	SeedDataHeaderT tmphdr;    /* temp store */
	float    dt;               /* sample rate */
	NTIME    rstart, rend;     /* record start and end times */
	NTIME    ntime;            /* numeric exact time */
	float    tdiff;            /* time difference in sec */
	int      cutlth;           /* number of samples to cut */
	long     smp[MAX_SMP_PER_REC]; /* space for decoded samples */
	long     smplth;           /* number of sample decoded */
	int      i;                /* counter */
	int      recs_used;        /* records used for encoding (should be 1) */

	/* executable code */

	/* retrieve header information needed here */
	hdrptr = (SeedDataHeaderT *)seedrec;
	dt = SeedGetSampleDist( hdrptr );
	SeedRecordTime( seedrec, &rstart, &rend, status );
	if  (SySevere(status))  return;
	tc_t2n( extime, &ntime, status );
	if  (SySevere(status))  return;
	tdiff = tc_ndiff( &ntime, &rstart, status );
	if  (SySevere(status))  return;
	cutlth = Nint( tdiff / dt );
	if  (cutlth > (int)(hdrptr->no_of_samples))  {
		*status = SeedERR_ILLCUT;
		return;
	} else if  (cutlth == (int)(hdrptr->no_of_samples))  {
		hdrptr->no_of_samples = 0;
		return;
	} else if  (cutlth <= 0)  {
		/* nothing to be done */
		return;
	} /*endif*/

	/* decode record */
	SeedDecodeSteim1( NULL, swap, 0, NULL, NULL );
	SeedDecodeSteim1( seedrec, swap, MAX_SMP_PER_REC, smp, &smplth );
	if  (smplth != (long)(hdrptr->no_of_samples))  {
		*status = SeedERR_DECODE_ERR;
		return;
	} /*endif*/

	/* throw away cutlth samples from the beginning */
	for  (i=cutlth; i<(int)smplth; i++)
		smp[i-cutlth] = smp[i];
	smplth -= (long)cutlth;
	tdiff = (float)cutlth * dt;
	tc_nadd( &rstart, tdiff, &rstart, status );
	if  (SySevere(status))  return;

	/* prepare changed record */
	outrec = (SeedDataHeaderT *)sy_allocmem( 2, seedv_setup.seed_rec_size,
		status );  /* get two records; need only one but who knows ... */
	hdrptr->no_of_samples = (UWORD)smplth;
	SeedNtimeToBtime( &rstart, &(hdrptr->starttime), status );
	if  (SySevere(status))  {
		sy_deallocmem( outrec );
		return;
	} /*endif*/
	recs_used = (int)Steim_comp( smp, (DATA_HEADER *)hdrptr, (ULONG)smplth,
		(WORD)(seedv_setup.seed_rec_size), (long *)outrec, 0 /*prev.smp*/ );
	if  (recs_used != 1)  {
		*status = SeedERR_BUG;
		sy_deallocmem( outrec );
		return;
	} /*endif*/
	/* copy result to output record and keep header */
	tmphdr = *hdrptr;
	memcpy( (char *)seedrec, (char *)outrec, seedv_setup.seed_rec_size );
	*hdrptr = tmphdr;
	sy_deallocmem( outrec );

} /* end of SeedCutStartRecord */



/*---------------------------------------------------------------------*/



void SeedCutEndRecord( SeedSbyteT *seedrec, char extime[], BOOLEAN swap,
	STATUS *status )

/* Throws away the first samples in record until given time
 *
 * parameters of routine
 * char       *seedrec;         modify; SEED record to cut
 * char       extime[];         input; exact time
 * BOOLEAN    swap;             input; swap bytes ?
 * STATUS     *status;          output; return status
 */
{
	/* local variables */
	SeedDataHeaderT *hdrptr;   /* pointer to data header */
	SeedDataHeaderT *outrec;   /* output records */
	SeedDataHeaderT tmphdr;    /* temp store */
	float    dt;               /* sample rate */
	NTIME    rstart, rend;     /* record start and end times */
	NTIME    ntime;            /* numeric exact time */
	float    tdiff;            /* time difference in sec */
	int      cutlth;           /* number of samples to cut */
	long     smp[MAX_SMP_PER_REC]; /* space for decoded samples */
	long     smplth;           /* number of sample decoded */
	int      i;                /* counter */
	int      recs_used;        /* records used for encoding (should be 1) */

	/* executable code */

	/* retrieve header information needed here */
	hdrptr = (SeedDataHeaderT *)seedrec;
	dt = SeedGetSampleDist( hdrptr );
	SeedRecordTime( seedrec, &rstart, &rend, status );
	if  (SySevere(status))  return;
	tc_t2n( extime, &ntime, status );
	if  (SySevere(status))  return;
	tdiff = tc_ndiff( &rend, &ntime, status );
	if  (SySevere(status))  return;
	cutlth = Nint( tdiff / dt );
	if  (cutlth > (int)(hdrptr->no_of_samples))  {
		*status = SeedERR_ILLCUT;
		return;
	} else if  (cutlth == (int)(hdrptr->no_of_samples))  {
		hdrptr->no_of_samples = 0;
		return;
	} else if  (cutlth <= 0)  {
		/* nothing to be done */
		return;
	} /*endif*/

	/* decode record */
	SeedDecodeSteim1( NULL, swap, 0, NULL, NULL );
	SeedDecodeSteim1( seedrec, swap, MAX_SMP_PER_REC, smp, &smplth );
	if  (smplth != (long)(hdrptr->no_of_samples))  {
		*status = SeedERR_DECODE_ERR;
		return;
	} /*endif*/

	/* throw away cutlth samples at the end */
	smplth -= (long)cutlth;

	/* prepare changed record */
	outrec = (SeedDataHeaderT *)sy_allocmem( 2, seedv_setup.seed_rec_size,
		status );  /* get two records; need only one but who knows ... */
	hdrptr->no_of_samples = (UWORD)smplth;
	recs_used = (int)Steim_comp( smp, (DATA_HEADER *)hdrptr, (ULONG)smplth,
		(WORD)(seedv_setup.seed_rec_size), (long *)outrec, 0 /*prev.smp*/ );
	if  (recs_used != 1)  {
		*status = SeedERR_BUG;
		sy_deallocmem( outrec );
		return;
	} /*endif*/
	/* copy result to output record and keep header */
	tmphdr = *hdrptr;
	memcpy( (char *)seedrec, (char *)outrec, seedv_setup.seed_rec_size );
	*hdrptr = tmphdr;
	sy_deallocmem( outrec );

} /* end of SeedCutEndRecord */



/*---------------------------------------------------------------------*/



char *SeedGetFilename( int chan )

/* returns name of currently opened file on channel 'chan'.  If no filename
 * is found, a pointer to an empty string is returned.
 *
 * parameters of routine
 * int        chan;        input; channel number
 *                         returns name of file
 */
{
	/* local variables */
	static char nullstr[2] = "";  /* null string */
	SeedFileDescrT *fd;   /* pointer to SEED file descriptor */

	/* executable code */

	/* check channel number */
	if  (chan < 0 || chan >= Seed_C_MAXCHAN)  return nullstr;
	fd = seedv_fd + chan;
	return ((fd->name[0] == '\0') ? seedv_last_fname : fd->name);

} /* end of SeedGetFilename */



/*---------------------------------------------------------------------*/



static void SeedSwapLinuxRecord( SeedSbyteT *rec )


/* Modifies record for writing on Linux system
 *
 * parameters of routine
 * SeedSbyteT *rec;                modify; SEED record
 */
{
	/* local variables */
	SeedSbyteT     *ptr;                /* moving pointer */
	SeedSbyteT     tmp;                 /* scratch */

	/* executable code */

	for  (ptr = rec+Seed_C_FRAMELTH; ptr < rec+seedv_setup.seed_rec_size;
		ptr += 4)  {
		/* flip 0 and 3 */
		tmp = ptr[0];  ptr[0] = ptr[3];  ptr[3] = tmp;
		/* flip 1 and 2 */
		tmp = ptr[1];  ptr[1] = ptr[2];  ptr[2] = tmp;
	} /*endfor*/

} /* end of SeedSwapLinuxRecord */



/*---------------------------------------------------------------------*/



/* FORTRAN interface routine */


void SeedReadStreamReal_( int chan, char sfdfile[], char stream_str[],
	BOOLEAN swap, char req_start[], float seclth, float **fdat,
	long *smplth, char act_start[], float *dt, float *calib,
	STATUS *status )
{

	SeedReadStreamReal( chan, sfdfile, stream_str, swap, req_start,
		seclth, fdat, smplth, act_start, dt, calib, status );

} /* end of SeedReadStreamReal_ */


void SeedLibInitialize_( STATUS *status )
{

	SeedLibInitialize( status );

} /* end of SeedLibInitialize_ */


void SeedSetup_( STATUS *status )
{
	static SeedSetupParT setup;

	SeedSetup( &setup, status );

} /* end of SeedSetup_ */


/*---------------------------------------------------------------------*/
